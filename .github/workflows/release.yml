name: Semantic Version Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      prerelease:
        description: 'Create a pre-release'
        required: false
        default: false
        type: boolean
      draft:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.12'
  REGISTRY: ghcr.io

jobs:
  version-bump:
    name: Version Bump and Tag
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      changelog_content: ${{ steps.changelog.outputs.content }}
      package_name: ${{ steps.package_info.outputs.name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install packaging python-semantic-release
        # Install TOML parser for compatibility
        pip install tomli toml

    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

    - name: Get current version and package info
      id: current_version
      run: |
        # Get version from Poetry
        CURRENT_VERSION=$(poetry version --short)
        PACKAGE_NAME=$(poetry version | cut -d' ' -f1)
        
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"
        echo "Package name: $PACKAGE_NAME"

    - name: Calculate new version
      id: version
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
        VERSION_TYPE="${{ github.event.inputs.version_type }}"
        
        python << EOF
        from packaging import version
        import sys
        
        current = version.parse("$CURRENT_VERSION")
        
        if "$VERSION_TYPE" == "major":
            new_version = f"{current.major + 1}.0.0"
        elif "$VERSION_TYPE" == "minor":
            new_version = f"{current.major}.{current.minor + 1}.0"
        elif "$VERSION_TYPE" == "patch":
            new_version = f"{current.major}.{current.minor}.{current.micro + 1}"
        else:
            print(f"Invalid version type: $VERSION_TYPE", file=sys.stderr)
            sys.exit(1)
        
        print(f"new_version={new_version}")
        
        # Write to GitHub outputs
        with open("$GITHUB_OUTPUT", "a") as f:
            f.write(f"new_version={new_version}\n")
        EOF

    - name: Extract package information
      id: package_info
      run: |
        NAME="${{ steps.current_version.outputs.package_name }}"
        echo "name=$NAME" >> $GITHUB_OUTPUT
        echo "üì¶ Package: $NAME"

    - name: Update version in pyproject.toml
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        poetry version $NEW_VERSION
        echo "Updated pyproject.toml to version $NEW_VERSION"
        
        # Verify the update
        UPDATED_VERSION=$(poetry version --short)
        echo "‚úÖ Verified updated version: $UPDATED_VERSION"

    - name: Extract changelog content for version
      id: changelog
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        
        # Extract changelog content for the current version
        python << 'EOF'
        import re
        import sys
        import os
        
        try:
            with open('CHANGELOG.md', 'r') as f:
                content = f.read()
            
            # Find the section for unreleased changes (first section)
            # Look for ## [Unreleased] - pattern
            pattern = r'^## \[(.*?)\] - (.*?)$'
            matches = list(re.finditer(pattern, content, re.MULTILINE))
            
            if matches:
                # Get content from end of first header to start of next section or end of file
                first_match = matches[0]
                start_pos = first_match.end()  # Start after the header line
                
                if len(matches) > 1:
                    # Find next section header
                    end_pos = matches[1].start()
                    changelog_section = content[start_pos:end_pos].strip()
                else:
                    # Use rest of file
                    changelog_section = content[start_pos:].strip()
                
                # Clean up the content
                if changelog_section:
                    # Remove extra whitespace and empty lines at start/end
                    lines = changelog_section.split('\n')
                    # Remove leading empty lines
                    while lines and not lines[0].strip():
                        lines.pop(0)
                    # Remove trailing empty lines
                    while lines and not lines[-1].strip():
                        lines.pop()
                    
                    changelog_content = '\n'.join(lines)
                    
                    # Write to GitHub output using environment file method for multiline
                    delimiter = "EOF_CHANGELOG"
                    with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                        f.write(f"content<<{delimiter}\n")
                        f.write(changelog_content)
                        f.write(f"\n{delimiter}\n")
                    
                    print(f"Extracted changelog content: {len(changelog_content)} characters")
                    print("Preview:")
                    print(changelog_content[:200] + "..." if len(changelog_content) > 200 else changelog_content)
                else:
                    print("No content found in changelog section")
                    with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                        f.write("content=No changelog content available\n")
            else:
                print("No changelog sections found")
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write("content=No changelog content available\n")
                    
        except Exception as e:
            print(f"Error extracting changelog: {e}", file=sys.stderr)
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("content=Error extracting changelog content\n")
        EOF

    - name: Update changelog with new version
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        CURRENT_DATE=$(date +%Y-%m-%d)
        
        # Update the first version section (unreleased) with the new version number and date
        sed -i "0,/^## \[.*\] - .*/s//## [$NEW_VERSION] - $CURRENT_DATE/" CHANGELOG.md
        
        echo "Updated CHANGELOG.md with version $NEW_VERSION and date $CURRENT_DATE"

    - name: Commit version bump
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        
        git add pyproject.toml CHANGELOG.md
        git commit -m "chore: bump version to $NEW_VERSION

        ü§ñ Generated with [Claude Code](https://claude.ai/code)

        Co-Authored-By: Claude <noreply@anthropic.com>"
        
        # Create and push tag
        git tag -a "v$NEW_VERSION" -m "Release version $NEW_VERSION"
        git push origin main
        git push origin "v$NEW_VERSION"

  build-python-package:
    name: Build Python Package
    runs-on: ubuntu-latest
    needs: version-bump
    outputs:
      package-version: ${{ steps.package-info.outputs.version }}
      package-name: ${{ steps.package-info.outputs.name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: v${{ needs.version-bump.outputs.new_version }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root

    - name: Install project
      run: poetry install --no-interaction

    - name: Extract package information
      id: package-info
      run: |
        VERSION=$(poetry version --short)
        NAME=$(poetry version | cut -d' ' -f1)
        echo "name=$NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Package: $NAME v$VERSION"

    - name: Build package
      run: |
        echo "üèóÔ∏è Building Python package..."
        poetry build
        
        echo "üìã Build results:"
        ls -la dist/
        
        echo "üìä Package checksums:"
        sha256sum dist/*

    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: python-packages-${{ needs.version-bump.outputs.new_version }}
        path: dist/*
        retention-days: 90

  build-docker-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [version-bump, build-python-package]
    permissions:
      contents: read
      packages: write
      id-token: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
      image-name: ${{ steps.image-name.outputs.lowercase }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: v${{ needs.version-bump.outputs.new_version }}

    - name: Convert repository name to lowercase
      id: image-name
      run: |
        LOWERCASE_REPO=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "lowercase=$LOWERCASE_REPO" >> $GITHUB_OUTPUT
        echo "üê≥ Docker image will be: ${{ env.REGISTRY }}/$LOWERCASE_REPO"

    - name: Install cosign
      uses: sigstore/cosign-installer@v3.5.0
      with:
        cosign-release: 'v2.2.4'

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log into registry ${{ env.REGISTRY }}
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Docker metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.lowercase }}
        tags: |
          type=raw,value=v${{ needs.version-bump.outputs.new_version }}
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=stable,enable=${{ github.event.inputs.prerelease == 'false' }}
        labels: |
          org.opencontainers.image.title=AI Prompt Manager
          org.opencontainers.image.description=Modern AI Prompt Management System with FastAPI Web UI, Multi-Language Support, and AI-Powered Optimization
          org.opencontainers.image.vendor=MakerCorn
          org.opencontainers.image.version=v${{ needs.version-bump.outputs.new_version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created={{date 'RFC3339'}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: ${{ github.event.inputs.draft == 'false' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64,linux/arm64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE={{date 'RFC3339'}}
          VCS_REF=${{ github.sha }}
          VERSION=v${{ needs.version-bump.outputs.new_version }}

    - name: Sign the Docker image
      if: github.event.inputs.draft == 'false'
      env:
        TAGS: ${{ steps.meta.outputs.tags }}
        DIGEST: ${{ steps.build.outputs.digest }}
      run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}

  publish-to-github-packages:
    name: Publish to GitHub Packages
    runs-on: ubuntu-latest
    needs: [version-bump, build-python-package, build-docker-image]
    permissions:
      contents: read
      packages: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: v${{ needs.version-bump.outputs.new_version }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages-${{ needs.version-bump.outputs.new_version }}
        path: ./dist

    - name: Configure Poetry for GitHub Packages
      run: |
        echo "üîß Configuring Poetry for GitHub Packages publishing..."
        echo "Repository: ${{ github.repository }}"
        echo "Repository Owner: ${{ github.repository_owner }}"
        echo "Actor: ${{ github.actor }}"
        echo "Package Name Issue: PyPI uses 'promptman', GitHub Packages expects 'ai-prompt-manager'"
        
        # Configure the GitHub Packages repository
        poetry config repositories.github https://pypi.pkg.github.com/${{ github.repository_owner }}
        poetry config http-basic.github ${{ github.actor }} ${{ secrets.GITHUB_TOKEN }}
        
        # Verify configuration
        echo "‚úÖ Poetry configuration:"
        poetry config --list | grep -E "(repositories|http-basic)" || true

    - name: Test GitHub Packages connectivity
      run: |
        echo "üîç Testing GitHub Packages connectivity..."
        # Test both user and org endpoints since we don't know which type of account this is
        echo "Testing user endpoint..."
        curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -H "Accept: application/vnd.github.v3+json" \
             https://api.github.com/users/${{ github.repository_owner }}/packages?package_type=pypi || echo "Note: User endpoint failed or no packages found"
        
        echo "Testing org endpoint..."
        curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -H "Accept: application/vnd.github.v3+json" \
             https://api.github.com/orgs/${{ github.repository_owner }}/packages?package_type=pypi || echo "Note: Org endpoint failed or no packages found"

    - name: Rebuild package for GitHub Packages
      run: |
        echo "üîß Rebuilding package for GitHub Packages with correct name..."
        echo "Issue: PyPI package name is 'promptman' but GitHub Packages expects repository name 'ai-prompt-manager'"
        
        # Create a temporary pyproject.toml for GitHub Packages with correct name
        cp pyproject.toml pyproject.github.toml
        
        # Update package name for GitHub Packages
        sed -i 's/name = "promptman"/name = "ai-prompt-manager"/' pyproject.github.toml
        
        echo "‚úÖ Created GitHub Packages configuration:"
        echo "Original package name: $(grep 'name = ' pyproject.toml)"
        echo "GitHub package name: $(grep 'name = ' pyproject.github.toml)"
        
        # Rebuild package with GitHub-specific name
        echo "üèóÔ∏è Building package for GitHub Packages..."
        rm -rf dist/*  # Clear existing packages
        
        # Temporarily replace pyproject.toml for build
        mv pyproject.toml pyproject.original.toml
        mv pyproject.github.toml pyproject.toml
        
        # Build with GitHub package name
        poetry build
        
        # Restore original pyproject.toml
        mv pyproject.toml pyproject.github.toml
        mv pyproject.original.toml pyproject.toml
        
        echo "üìã GitHub Packages build results:"
        ls -la dist/
        
        echo "üìä Package checksums:"
        sha256sum dist/*

    - name: Publish to GitHub Packages
      run: |
        echo "üöÄ Publishing to GitHub Packages..."
        echo "Using GitHub-specific package name: ai-prompt-manager"
        echo "Target repository: https://pypi.pkg.github.com/${{ github.repository_owner }}"
        
        # Use the GitHub-specific configuration for publishing
        mv pyproject.toml pyproject.original.toml
        mv pyproject.github.toml pyproject.toml
        
        # Try Poetry first with GitHub-specific config
        if ! poetry publish --repository github --no-interaction --verbose; then
          echo "‚ö†Ô∏è Poetry publishing failed, trying alternative method with twine..."
          
          # Install twine for alternative upload
          pip install twine
          
          # Upload using twine directly
          if ! python -m twine upload --repository-url https://pypi.pkg.github.com/${{ github.repository_owner }} \
                                      --username ${{ github.actor }} \
                                      --password ${{ secrets.GITHUB_TOKEN }} \
                                      --verbose \
                                      dist/*; then
            echo "‚ùå Both Poetry and Twine failed to publish to GitHub Packages"
            echo ""
            echo "üîß Possible solutions:"
            echo "1. Package name mismatch: PyPI='promptman', GitHub Packages needs 'ai-prompt-manager'"
            echo "2. Ensure GitHub Packages is enabled for this repository"
            echo "3. Check if the repository owner (${{ github.repository_owner }}) has GitHub Packages permissions"
            echo "4. Verify the GITHUB_TOKEN has 'packages: write' permission"
            echo "5. For first-time publishing, you may need to manually create the package first"
            echo ""
            echo "üìã Manual publishing instructions:"
            echo "   # Rename package in pyproject.toml to 'ai-prompt-manager'"
            echo "   # Then run:"
            echo "   pip install twine"
            echo "   twine upload --repository-url https://pypi.pkg.github.com/${{ github.repository_owner }} \\"
            echo "                --username YOUR_GITHUB_USERNAME \\"
            echo "                --password YOUR_GITHUB_TOKEN \\"
            echo "                dist/*"
            echo ""
            echo "‚è≠Ô∏è Continuing with release process (PyPI publishing will still work)..."
            # Don't exit 1 here to allow the rest of the release to continue
          else
            echo "‚úÖ Successfully published to GitHub Packages using twine!"
          fi
        else
          echo "‚úÖ Successfully published to GitHub Packages using Poetry!"
        fi
        
        # Restore original pyproject.toml
        mv pyproject.toml pyproject.github.toml
        mv pyproject.original.toml pyproject.toml
        echo "‚úÖ Restored original pyproject.toml configuration"

    - name: Verify GitHub Packages publication
      run: |
        GITHUB_PACKAGE_NAME="ai-prompt-manager"  # GitHub Packages uses repository name
        PYPI_PACKAGE_NAME="${{ needs.build-python-package.outputs.package-name }}"  # This is 'promptman'
        PACKAGE_VERSION="${{ needs.build-python-package.outputs.package-version }}"
        
        echo "üîç Verifying publication on GitHub Packages..."
        echo "GitHub Package Name: $GITHUB_PACKAGE_NAME (repository name)"
        echo "PyPI Package Name: $PYPI_PACKAGE_NAME (different from GitHub)"
        echo "Version: $PACKAGE_VERSION"
        echo "üì¶ GitHub Packages URL: https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/packages"

  publish-to-pypi:
    name: Publish to PyPI (Trusted Publishing)
    runs-on: ubuntu-latest
    needs: [version-bump, build-python-package, build-docker-image]
    # Only publish if not a pre-release and not in draft mode
    if: github.event.inputs.prerelease == 'false' && github.event.inputs.draft == 'false'
    environment:
      name: pypi
      url: https://pypi.org/p/${{ needs.build-python-package.outputs.package-name }}
    permissions:
      contents: read
      packages: write
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing
    
    steps:
    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages-${{ needs.version-bump.outputs.new_version }}
        path: ./dist

    - name: Verify package contents
      run: |
        echo "üì¶ Built packages:"
        ls -la dist/
        echo "üìù Package contents:"
        python -m pip install twine
        twine check dist/*

    - name: Publish to PyPI using Trusted Publishing
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        # Repository URL is automatically set for PyPI when not specified
        # Trusted publishing eliminates need for API tokens
        verbose: true
        print-hash: true

    - name: Verify PyPI publication
      run: |
        PACKAGE_NAME="${{ needs.build-python-package.outputs.package-name }}"
        PACKAGE_VERSION="${{ needs.build-python-package.outputs.package-version }}"
        
        echo "üîç Verifying publication on PyPI..."
        echo "Package: $PACKAGE_NAME"
        echo "Version: $PACKAGE_VERSION"
        
        # Wait a moment for PyPI to process
        echo "‚è≥ Waiting for PyPI to process the upload..."
        sleep 30
        
        # Try to fetch the package info from PyPI API
        if curl -f "https://pypi.org/pypi/$PACKAGE_NAME/$PACKAGE_VERSION/json" > /dev/null 2>&1; then
          echo "‚úÖ Package successfully published and available on PyPI!"
          echo "üì¶ PyPI URL: https://pypi.org/project/$PACKAGE_NAME/$PACKAGE_VERSION/"
        else
          echo "‚ö†Ô∏è Package may still be processing on PyPI. Check manually:"
          echo "üì¶ PyPI URL: https://pypi.org/project/$PACKAGE_NAME/"
        fi

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version-bump, build-python-package, build-docker-image, publish-to-github-packages, publish-to-pypi]
    # Always run this job, even if GitHub Packages or PyPI publishing fails, but skip if draft mode
    if: always() && github.event.inputs.draft == 'false' && (needs.version-bump.result == 'success' && needs.build-python-package.result == 'success' && needs.build-docker-image.result == 'success' && (needs.publish-to-github-packages.result == 'success' || needs.publish-to-github-packages.result == 'failure') && (needs.publish-to-pypi.result == 'success' || needs.publish-to-pypi.result == 'skipped'))
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: v${{ needs.version-bump.outputs.new_version }}
        fetch-depth: 0

    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages-${{ needs.version-bump.outputs.new_version }}
        path: ./dist

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.version-bump.outputs.new_version }}
        name: AI Prompt Manager v${{ needs.version-bump.outputs.new_version }}
        body: |
          # üöÄ AI Prompt Manager v${{ needs.version-bump.outputs.new_version }}
          
          Modern AI Prompt Management System with FastAPI Web UI, complete CRUD operations, multi-language support, and AI-powered optimization services.
          
          ## üåü What's New
          
          ${{ needs.version-bump.outputs.changelog_content }}
          
          ## üì¶ Installation Options
          
          ### üê≥ Docker (Recommended)
          ```bash
          # Quick start
          docker run -p 7860:7860 ghcr.io/${{ needs.build-docker-image.outputs.image-name }}:v${{ needs.version-bump.outputs.new_version }}
          
          # Production with PostgreSQL
          docker-compose -f docker-compose.prod.yml up -d
          ```
          
          ### üìö Python Package
          ```bash
          # Install from PyPI (Recommended)
          pip install ${{ needs.build-python-package.outputs.package-name }}==${{ needs.build-python-package.outputs.package-version }}
          
          # Or install from GitHub Packages (uses repository name)
          pip install --index-url https://pypi.pkg.github.com/${{ github.repository_owner }}/simple/ ai-prompt-manager==${{ needs.build-python-package.outputs.package-version }}
          
          # Run the application
          python -m promptman
          ```
          
          ### üîß Manual Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd ai-prompt-manager
          git checkout v${{ needs.version-bump.outputs.new_version }}
          poetry install
          poetry run python run.py  # CRITICAL: Use Poetry environment to avoid dependency issues
          ```
          
          ## üõ†Ô∏è Key Features
          
          - **FastAPI Web UI**: Modern responsive interface with HTMX and Tailwind CSS
          - **Hybrid Architecture**: Service Layer, Repository Pattern, and clean separation of concerns
          - **Multi-Service Prompt Optimizer**: LangWatch, PromptPerfect, LangSmith, Helicone support
          - **Multi-Language Interface**: 10 languages with real-time switching
          - **Unified Architecture**: Single codebase for single-user and multi-tenant modes
          - **Advanced Security**: JWT, RBAC, SSO/ADFS integration with modern password handling
          - **REST API**: Comprehensive API with interactive documentation
          - **Token Calculator**: Real-time cost estimation for AI models
          - **Prompt Builder**: Drag-and-drop interface for combining prompts
          - **Type Safety**: Full type hints and validation throughout the codebase
          - **Comprehensive Testing**: Complete test suite including E2E browser automation with Playwright
          
          ## üê≥ Docker Images
          
          | Tag | Description | Image |
          |-----|-------------|-------|
          | `v${{ needs.version-bump.outputs.new_version }}` | This release | `ghcr.io/${{ needs.build-docker-image.outputs.image-name }}:v${{ needs.version-bump.outputs.new_version }}` |
          | `latest` | Latest stable release | `ghcr.io/${{ needs.build-docker-image.outputs.image-name }}:latest` |${{ github.event.inputs.prerelease == 'false' && '
          | `stable` | Latest stable release | `ghcr.io/${{ needs.build-docker-image.outputs.image-name }}:stable` |' || '' }}
          
          **Image Digest:** `${{ needs.build-docker-image.outputs.image-digest }}`
          
          ## üìã Release Assets
          
          - **PyPI Package**: Available on [PyPI](https://pypi.org/project/${{ needs.build-python-package.outputs.package-name }}/${{ needs.build-python-package.outputs.package-version }}/) for easy installation
          - **GitHub Packages**: Available on [GitHub Packages](https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/packages) for enterprise users
          - **Python Packages**: Wheel and source distributions (attached to this release)
          - **Docker Images**: Multi-platform container images (amd64, arm64)
          - **Documentation**: Complete user guides and API documentation
          
          ## üîê Security & Verification
          
          - All packages include SHA256 checksums
          - Docker images are signed with Sigstore/Cosign
          - Release builds are reproducible and auditable
          
          ## üìñ Documentation
          
          - [Complete User Guide](https://github.com/${{ github.repository }}/blob/v${{ needs.version-bump.outputs.new_version }}/README.md)
          - [System Architecture](https://github.com/${{ github.repository }}/blob/v${{ needs.version-bump.outputs.new_version }}/docs/ARCHITECTURE.md)
          - [Installation Guide](https://github.com/${{ github.repository }}/blob/v${{ needs.version-bump.outputs.new_version }}/README.md#-quick-start)
          - [API Documentation](https://github.com/${{ github.repository }}/blob/v${{ needs.version-bump.outputs.new_version }}/README.md#-api-access)
          
          ## üêõ Issues & Support
          
          - [Report Issues](https://github.com/${{ github.repository }}/issues)
          - [Discussions](https://github.com/${{ github.repository }}/discussions)
          - [Contributing Guide](https://github.com/${{ github.repository }}/blob/v${{ needs.version-bump.outputs.new_version }}/README.md#-development)
          
          ---
          
          ü§ñ Generated with [Claude Code](https://claude.ai/code)
        files: |
          dist/*
        draft: ${{ github.event.inputs.draft }}
        prerelease: ${{ github.event.inputs.prerelease }}
        generate_release_notes: false

  notify-success:
    name: Notify Release Success
    runs-on: ubuntu-latest
    needs: [version-bump, build-python-package, build-docker-image, create-github-release, publish-to-github-packages, publish-to-pypi]
    if: always() && needs.build-python-package.result == 'success' && needs.build-docker-image.result == 'success'

    steps:
    - name: Success notification
      run: |
        echo "üéâ Release v${{ needs.version-bump.outputs.new_version }} completed successfully!"
        echo "üì¶ Python package: ${{ needs.build-python-package.outputs.package-name }} v${{ needs.build-python-package.outputs.package-version }}"
        echo "üê≥ Docker image: ghcr.io/${{ needs.build-docker-image.outputs.image-name }}:v${{ needs.version-bump.outputs.new_version }}"
        echo "üìã Release notes: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.version-bump.outputs.new_version }}"
        
        # Check GitHub Packages publishing
        if [[ "${{ needs.publish-to-github-packages.result }}" == "success" ]]; then
          echo "üì¶ GitHub Packages: https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/packages"
          echo "‚úÖ Package successfully published to GitHub Packages!"
        elif [[ "${{ needs.publish-to-github-packages.result }}" == "failure" ]]; then
          echo "‚ö†Ô∏è GitHub Packages publishing failed - this is often due to first-time setup requirements"
          echo "üìã Manual setup may be needed: https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/packages"
          echo "üí° See job logs for detailed troubleshooting steps"
        fi
        
        # Check if PyPI publishing was attempted
        if [[ "${{ github.event.inputs.prerelease }}" == "false" && "${{ github.event.inputs.draft }}" == "false" ]]; then
          if [[ "${{ needs.publish-to-pypi.result }}" == "success" ]]; then
            echo "üì¶ PyPI: https://pypi.org/project/${{ needs.build-python-package.outputs.package-name }}/${{ needs.build-python-package.outputs.package-version }}/"
            echo "‚úÖ Package successfully published to PyPI using Trusted Publishing!"
          elif [[ "${{ needs.publish-to-pypi.result }}" == "failure" ]]; then
            echo "‚ùå PyPI publishing failed - check the publish-to-pypi job logs"
          fi
        else
          echo "‚è≠Ô∏è PyPI publishing skipped (pre-release or draft mode)"
        fi
        
        echo ""
        echo "‚úÖ All release tasks completed!"