name: "Create Release"

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for manual release'
        required: true
        type: string

permissions:
  contents: write
  packages: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    steps:
      - name: Set release tag
        id: set_tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag_name }}"
          else
            TAG_NAME="${{ github.ref_name }}"
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Using tag: $TAG_NAME"
      
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.set_tag.github.ref_name }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies and build package
        run: |
          poetry install --no-interaction
          poetry build

      - name: Create release distribution
        run: |
          # Create comprehensive release package
          RELEASE_DIR="ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}"
          mkdir -p "$RELEASE_DIR"
          
          echo "ðŸ“¦ Creating release package: $RELEASE_DIR"
          
          # Copy built packages
          if [ -d "dist" ] && [ "$(ls -A dist)" ]; then
            echo "Copying built packages..."
            cp dist/* "$RELEASE_DIR/"
          else
            echo "âš ï¸ No built packages found in dist/"
          fi
          
          # Copy essential files with existence checks
          echo "Copying essential files..."
          for file in README.md LICENSE CHANGELOG.md .env.example docker-compose.yml docker-compose.prod.yml Dockerfile pyproject.toml poetry.lock; do
            if [ -f "$file" ]; then
              cp "$file" "$RELEASE_DIR/"
              echo "âœ… Copied $file"
            else
              echo "âš ï¸ Missing file: $file"
            fi
          done
          
          # Copy Python source files
          echo "Copying Python source files..."
          for file in *.py; do
            if [ -f "$file" ]; then
              cp "$file" "$RELEASE_DIR/"
            fi
          done
          
          echo "âœ… Release package contents:"
          ls -la "$RELEASE_DIR/"
          
          # Create installation script
          cat > ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}/install.sh << 'EOF'
          #!/bin/bash
          echo "ðŸš€ AI Prompt Manager ${{ steps.set_tag.outputs.tag_name }} Installation"
          echo "================================================="
          
          # Check Python version
          python_version=$(python3 --version 2>&1 | sed 's/.* \([0-9]\.[0-9]*\).*/\1/')
          required_version="3.12"
          if [ "$(printf '%s\n' "$required_version" "$python_version" | sort -V | head -n1)" != "$required_version" ]; then
              echo "âŒ Python 3.12+ is required. Found: $python_version"
              exit 1
          fi
          
          # Check if Poetry is installed
          if ! command -v poetry &> /dev/null; then
              echo "ðŸ“¦ Installing Poetry..."
              curl -sSL https://install.python-poetry.org | python3 -
              export PATH="$HOME/.local/bin:$PATH"
          fi
          
          # Install dependencies
          echo "ðŸ“š Installing dependencies..."
          poetry install --no-interaction
          
          # Copy environment file
          if [ ! -f .env ]; then
              echo "âš™ï¸ Creating .env configuration file..."
              cp .env.example .env
              echo "âœ… Please edit .env file to configure your deployment"
          fi
          
          echo ""
          echo "âœ… AI Prompt Manager ${{ steps.set_tag.outputs.tag_name }} installed successfully!"
          echo ""
          echo "ðŸš€ Quick Start Commands:"
          echo "  poetry run python run.py                    # Multi-tenant mode"
          echo "  poetry run python run.py --single-user      # Single-user mode" 
          echo "  poetry run python run.py --with-api         # Multi-tenant + API"
          echo "  poetry run python run.py --help             # Show all options"
          echo ""
          echo "ðŸ³ Docker Commands:"
          echo "  docker-compose up -d                        # Development"
          echo "  docker-compose -f docker-compose.prod.yml up -d  # Production"
          echo ""
          echo "ðŸ“– Full Documentation: README.md"
          echo "ðŸ”§ Configuration Guide: .env.example"
          EOF
          
          chmod +x ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}/install.sh
          
          # Create archives
          echo "ðŸ“¦ Creating release archives..."
          tar -czf ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.tar.gz ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}/
          zip -r ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.zip ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}/
          
          # Verify archives were created
          echo "âœ… Release archives created:"
          ls -lh ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.tar.gz ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.zip

      - name: Generate changelog
        id: changelog
        run: |
          # Check if this is actually a tag release
          if [[ "${{ steps.set_tag.outputs.tag_name }}" != v*.*.* ]]; then
            echo "âš ï¸ This is not a version tag release (ref: ${{ steps.set_tag.outputs.tag_name }})"
            echo "Skipping changelog generation for non-tag releases"
            echo "CHANGELOG=## Manual Release
            exit 0
          fi
          
          # Get the previous tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | sed -n '2p')
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tag found, using initial commit"
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
          else
            echo "Previous tag: $PREVIOUS_TAG"
          fi
          
          echo "Current tag: ${{ steps.set_tag.outputs.tag_name }}"
          
          # Generate changelog
          echo "## What's Changed in ${{ steps.set_tag.outputs.tag_name }}" > RELEASE_CHANGELOG.md
          echo "" >> RELEASE_CHANGELOG.md
          
          # Get commits since last tag
          if git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..HEAD >> RELEASE_CHANGELOG.md 2>/dev/null; then
            echo "âœ… Generated changelog from commits"
          else
            echo "âš ï¸ No commits found, creating basic changelog"
            echo "- Release ${{ steps.set_tag.outputs.tag_name }}" >> RELEASE_CHANGELOG.md
          fi
          
          # Save changelog for use in release body
          # No need for GitHub output, we'll use the file directly
          echo "ðŸ“ Changelog saved to RELEASE_CHANGELOG.md"
          
          echo "Generated changelog:"
          cat RELEASE_CHANGELOG.md

      - name: Create release body
        run: |
          TAG_NAME="${{ steps.set_tag.outputs.tag_name }}"
          cat > RELEASE_BODY.md << EOF
          # ðŸš€ AI Prompt Manager $TAG_NAME
          
          ## ðŸ“¦ Installation Options
          
          ### Option 1: Download Release Package (Recommended)
          1. Download \`ai-prompt-manager-$TAG_NAME.tar.gz\` or \`.zip\` from the assets below
          2. Extract the archive: \`tar -xzf ai-prompt-manager-$TAG_NAME.tar.gz\`
          3. Run the installer: \`cd ai-prompt-manager-$TAG_NAME && chmod +x install.sh && ./install.sh\`
          4. Start the application: `poetry run python run.py`
          
          ### Option 2: Docker Deployment
          ```bash
          # Development
          docker-compose up -d
          
          # Production
          docker-compose -f docker-compose.prod.yml up -d
          ```
          
          ### Option 3: Poetry Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd ai-prompt-manager
          git checkout $TAG_NAME
          poetry install
          poetry run python run.py
          ```
          
          ## ðŸŒŸ Features
          - ðŸ” **Unified Architecture**: Single codebase supporting both single-user and multi-tenant modes
          - ðŸš€ **Universal Launcher**: Environment-based configuration with `run.py`
          - ðŸ”‘ **Multi-tenant Authentication**: SSO/ADFS support with role-based access control
          - ðŸ¤– **AI Integration**: LangWatch prompt optimization and token cost estimation
          - ðŸ“Š **REST API**: Comprehensive API with OpenAPI documentation
          - ðŸ›¡ï¸ **Admin Panel**: Tenant and user management interface
          - ðŸ—„ï¸ **Database Flexibility**: SQLite for development, PostgreSQL for production
          - ðŸ³ **Docker Ready**: Production-ready containerization
          
          ## ðŸš€ Quick Start Commands
          ```bash
          # Multi-tenant mode (default)
          python run.py
          
          # Single-user mode
          python run.py --single-user
          
          # Multi-tenant with API
          python run.py --with-api
          
          # Custom configuration
          MULTITENANT_MODE=true ENABLE_API=true python run.py
          ```
          
          ## ðŸ” Default Development Credentials
          - **Email**: admin@localhost
          - **Password**: admin123  
          - **Tenant**: localhost
          
          ## ðŸŒ Access URLs
          - **Web Interface**: http://localhost:7860
          - **API Documentation**: http://localhost:7860/api/docs
          - **API Reference**: http://localhost:7860/api/redoc
          
          ## ðŸ“‹ Package Contents
          - **Source Code**: All Python modules and configuration files
          - **Documentation**: README.md, CHANGELOG.md, and configuration guides
          - **Docker Support**: Dockerfile and docker-compose configurations
          - **Installation Script**: Automated setup with `install.sh`
          - **Built Packages**: Python wheel and source distribution
          
          EOF
          
          # Append changelog if it exists
          if [ -f "RELEASE_CHANGELOG.md" ]; then
            echo "" >> RELEASE_BODY.md
            cat RELEASE_CHANGELOG.md >> RELEASE_BODY.md
          fi
          
          # Add footer
          cat >> RELEASE_BODY.md << 'EOF'
          
          ---
          
          **ðŸ” Secure â€¢ ðŸ¢ Multi-Tenant â€¢ ðŸš€ Scalable â€¢ ðŸ¤– AI-Powered â€¢ ðŸ”Œ API-Ready**
          EOF

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.set_tag.outputs.tag_name }}
          name: AI Prompt Manager ${{ steps.set_tag.outputs.tag_name }}
          body_path: RELEASE_BODY.md
          draft: false
          prerelease: false
          files: |
            ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.tar.gz
            ai-prompt-manager-${{ steps.set_tag.outputs.tag_name }}.zip
